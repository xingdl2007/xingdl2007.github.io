<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[程嵇邢滑の部落格]]></title><description><![CDATA[A Place of No Significance ]]></description><link>https://griddy.netlify.com/</link><generator>RSS for Node</generator><lastBuildDate>Sun, 10 Nov 2019 14:52:30 GMT</lastBuildDate><item><title><![CDATA[LevelDB日知录]]></title><description><![CDATA[初识LevelDB 说起LevelDb也许您不清楚，但是如果作为IT工程师，不知道下面两位大神级别的工程师，那您的领导估计会Hold不住了：Jeff Dean和Sanjay Ghemawat。这两位是Google公司重量级的工程师，为数甚少的Google Fellow…]]></description><link>https://griddy.netlify.com//blog/leveldb/</link><guid isPermaLink="false">https://griddy.netlify.com//blog/leveldb/</guid><pubDate>Sun, 10 Nov 2019 21:39:06 GMT</pubDate><content:encoded>&lt;h2&gt;初识LevelDB&lt;/h2&gt;
&lt;p&gt;说起LevelDb也许您不清楚，但是如果作为IT工程师，不知道下面两位大神级别的工程师，那您的领导估计会Hold不住了：Jeff Dean和Sanjay Ghemawat。这两位是Google公司重量级的工程师，为数甚少的Google Fellow之二。&lt;/p&gt;
&lt;p&gt;Jeff Dean其人：&lt;a href=&quot;http://research.google.com/people/jeff/index.html&quot;&gt;http://research.google.com/people/jeff/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google大规模分布式平台Bigtable和MapReduce主要设计和实现者。&lt;/p&gt;
&lt;p&gt;Sanjay Ghemawat其人：&lt;a href=&quot;http://research.google.com/people/sanjay/index.html&quot;&gt;http://research.google.com/people/sanjay/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google大规模分布式平台GFS，Bigtable和MapReduce主要设计和实现工程师。&lt;/p&gt;
&lt;p&gt;LevelDb就是这两位大神级别的工程师发起的开源项目，简而言之，LevelDb是能够处理十亿级别规模Key-Value型数据持久性存储的C++程序库。正像上面介绍的，这二位是Bigtable的设计和实现者，如果了解Bigtable的话，应该知道在这个影响深远的分布式存储系统中有两个核心的部分：Master Server和Tablet Server。其中Master Server做一些管理数据的存储以及分布式调度工作，实际的分布式数据存储以及读写操作是由Tablet Server完成的，而LevelDb则可以理解为一个简化版的Tablet Server。&lt;/p&gt;
&lt;p&gt;LevelDb有如下一些特点：&lt;/p&gt;
&lt;p&gt;首先，LevelDb是一个持久化存储的KV系统，和Redis这种内存型的KV系统不同，LevelDb不会像Redis一样狂吃内存，而是将大部分数据存储到磁盘上。&lt;/p&gt;
&lt;p&gt;其次，LevleDb在存储数据时，是根据记录的key值有序存储的，就是说相邻的key值在存储文件中是依次顺序存储的，而应用可以自定义key大小比较函数，LevleDb会按照用户定义的比较函数依序存储这些记录。&lt;/p&gt;
&lt;p&gt;再次，像大多数KV系统一样，LevelDb的操作接口很简单，基本操作包括写记录，读记录以及删除记录。也支持针对多条操作的原子批量操作。&lt;/p&gt;
&lt;p&gt;另外，LevelDb支持数据快照（snapshot）功能，使得读取操作不受写操作影响，可以在读操作过程中始终看到一致的数据。&lt;/p&gt;
&lt;p&gt;除此外，LevelDb还支持数据压缩等操作，这对于减小存储空间以及增快IO效率都有直接的帮助。&lt;/p&gt;
&lt;p&gt;LevelDb性能非常突出，官方网站报道其随机写性能达到40万条记录每秒，而随机读性能达到6万条记录每秒。总体来说，LevelDb的写操作要大大快于读操作，而顺序读写操作则大大快于随机读写操作。至于为何是这样，看了朗格科技后续推出的LevelDb日知录，估计您会了解其内在原因。&lt;/p&gt;
&lt;p&gt;说明：文章来源自 朗格科技 ，原文链接已失效（未完，待续）&lt;/p&gt;</content:encoded></item><item><title><![CDATA[如何提升你的能力？给年轻程序猿的几条建议]]></title><description><![CDATA[一转眼工作已有8年，前两天公司一位初入职场的同事希望我给一些建议与经验。我觉得这个话题很有价值，这里以个人的想法与经历写成此文，希望给年轻的开发者们一些启发。 我工作过的公司有4家，NVIDIA, Google, Slide和Glow。其中两家是知名的大公司，Slide我是D…]]></description><link>https://griddy.netlify.com//blog/how-to-improve/</link><guid isPermaLink="false">https://griddy.netlify.com//blog/how-to-improve/</guid><pubDate>Sun, 10 Nov 2019 21:32:41 GMT</pubDate><content:encoded>&lt;p&gt;一转眼工作已有8年，前两天公司一位初入职场的同事希望我给一些建议与经验。我觉得这个话题很有价值，这里以个人的想法与经历写成此文，希望给年轻的开发者们一些启发。&lt;/p&gt;
&lt;p&gt;我工作过的公司有4家，NVIDIA, Google, Slide和Glow。其中两家是知名的大公司，Slide我是D轮过后加入的，那时约150人。Glow则是从它第一天创立，一直走到现在。个人的工作也从Developer，Tech Lead，Engineering Manager到CTO。这些经历使我对程序员的个人发展之路有比较全面的看法。&lt;/p&gt;
&lt;p&gt;如果你问一个年轻的前端开发人员，你在今后的3年内如何提升自己的能力？他可能会说“我现在对Web前端比较熟悉，但我想深入了解AngularJS，另外React现在发展的很快我也想看一下。之后，我会花时间去学习iOS和Android开发。”看上去不错，但缺乏系统性的目标。或者说，他制定了学什么，但对为什么要学这些并没有仔细的思考。&lt;/p&gt;
&lt;p&gt;在技术领域，有太多的东西会迅速的过时，如何利用有限时间，最大化你的长期收益？这里我可以给出几条建议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打造你的工具箱&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工欲善其事，必先利其器。每个开发者都应该有一把自己的瑞士军刀，在将来漫长的职业生涯中，这些工具可以为你省下宝贵的时间，并帮助你更好的组织个人知识库。举两个例子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一套高效的开发环境&lt;/li&gt;
&lt;li&gt;一个信息采集器和一本笔记本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;高效的开发环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以从编缉器谈起，这里有IDE vs Text Editor，有Vim vs Emacs，有Sublime vs Atom，那该如何选择呢？在做选择之前，我们先想想自己的目标。我们希望这是一个长期的投资，这款编缉器能被长期使用，在这个过程不断的打磨，使其能完全适合自己的习惯，最大化编缉效率。如果程序员是侠客，编缉器则是他手中的剑。&lt;/p&gt;
&lt;p&gt;虽然我是Vim的重度用户，但我觉得当年选择Vim时有欠考虑。如果让我重选一次，我的第一选择会是Emacs，第二选择会是Atom。Emacs已存在30年，社区仍然活跃，其可扩展性在编缉器中无人能出其右。Emacs的脚本语言elisp又是lisp的一种dialect，我觉得对lisp的学习可以提升程序员对编程核心思想的理解。另一个加分点是Emacs由于其本身的高门槛及lisp特质，吸引了大批高质素的程序员，其社区可谓藏龙卧虎，更诞生了像Org-mode这样神级的插件。反观Vim，Vim的精髓在于Mode editing，这是值得学习的，可以极大提高文本编缉的效率。但当你熟悉了这一理念后，我觉得可以转投其他编缉器，因为Vim的架构与Vimscript限制了其扩展性。Emacs通过Evil插件非常完整的支持了Mode editing，其他主流的编辑器也有类似插件，所以你一旦掌握了这个理念，在别的编辑器中也可以发挥作用。可能有人会说没有一个Vim emulator能做到Vim 100%的功能，但重点不在于某条指令是否被移植，而是mode editing思想的精髓能否被移植，我觉得答案是肯定的。&lt;/p&gt;
&lt;p&gt;再看Atom vs Sublime，Atom的可扩展性非常好，它的大部分核心功能也是以插件的方式实现，这点与Emacs有异曲同工之妙。并且其开源的特性，使我相信它有比Sublime更持久的生命力。&lt;/p&gt;
&lt;p&gt;关于IDE，我的看法是，我不排斥IDE，但每个IDE都是为了某个特定的任务或是编程语言服务的。做为一个有追求的程序员，可以用IDE，但依然需要精通一个强大的通用编缉器。&lt;/p&gt;
&lt;p&gt;类似编缉器，高效的开发环境还包括Shell，Launcher，窗口管理器，文档阅读器等等。其中有一部分只需要你化很少的时间就可以完成配置，它们的投资回报率是非常高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信息采集器和笔记本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前者是用来收集别人产生的信息，后者则是收集自己产生的信息。前者一个简单的例子就是浏览器的Bookmark。你需要能随时将一组有用的信息归档，并在未来的某个时刻快速找到它。后者最直观的例子则是Mac OS或是iOS自带的笔记本，这里的目的是能随时随地记录你自己的想法。从本质上讲，就是你需要有一套好用的工具来做你的知识库管理（Knowledge management），也可以说是你知识和思想的外部备份。我个人现在是用Evernote同时来做信息采集与笔记的。如果有一个好的流程，你也完全可以用两个工具来分别把这两件事做好。但我建议你花足够多的时间来思考如何组织你的个人知识库。&lt;/p&gt;
&lt;p&gt;以上只是两个典型的例子，你需要做的是发现那些你要长期从事的任务（往往不随技术而改变，也不随公司而改变），将完成这些任务所需的工具调整至最优。再举一个例子，我会留意身边的程序员所用的键盘。只有少部分的程序员会买高端的静电容键盘，比如HHKB。而在我看来，这明显是一笔很划得来的投资，程序员在工作的大部分时间里都需要和键盘打交道，一个舒适的打字体验是非常有收益的，更何况这类高品质的键盘都非常的耐用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开阔你的视野，构建你的技术体系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先你要给自己设定一个目标，就如同一个公司会设定它的Vision。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标要够大，这样你才能看到更多的风景。&lt;/li&gt;
&lt;li&gt;目标应该设定在解决哪一类问题，而不是精通哪一类技术。技术只是手段，不是目的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，“我要成为iOS developer中的达人”这个目标，就远不如“我要成为前端应用开发的专家”来得有意义。前者学到深处你可能会去钻研iOS framework里各种奇技淫巧，而后者你会开始关注视觉与交互设计，研究各平台间的差异与共同趋势。显然，后者更有助于你的个人发展。&lt;/p&gt;
&lt;p&gt;不过即便有了明确的目标，选择哪一类技术学习，如何学习，在信息过载的今天依然是一个难题。常有的观点是应该学习最新的技术，因为老的已经过时，而反对的观点则是新技术还不成熟。我个人的观点是，当初入一个领域时，选择主流技术框架；当你有一定经验后，选择技术时更应该关注背后的推动者，我相信优秀的人和团队总能打造优秀的产品，无论是商业公司还是开源社区。不必太在意技术的新旧，因为可能很快都会成为过去时。你真正要学习的是技术背后的思想。有不少语言与开源项目会写它的Coding philosophy，这是很有意思的，你可以从它们的源代码中去验证这些编程理念。以Python为例，如果你执行import this就会看到它的理念，再如Python中一个著名的开源库Celery，在它的文档有专门一节讲述它的&lt;a href=&quot;http://celery.readthedocs.org/en/latest/internals/guide.html#philosophy&quot;&gt;编程理念&lt;/a&gt;。它们对你的影响会比这些技术本身来得更深远，这是我给初学者们的一个忠告。同理，我非常推荐读一些优秀开源库或是语言的源代码，例如Python的标准库绝大部分都是用Python实现的，而且可读性非常好。如果学习一门技术仅仅停留在用的层面上，你就还没有完全吸取其中的精华，而且学习的收益会随着技术的过时而消失。&lt;/p&gt;
&lt;p&gt;我的另一个学习原则是，在选择学习一门新技术时，最大化它与你现有知识库的差异性。读起来可能有拗口，例如你会Django，接下去你应该去学习Ruby on Rails还是NodeJS? 依据这个原则，你应该学NodeJS，因为它的异步IO模型在理念上与Django的同步模型差异很大，而RoR则与Django更多相似之处。但更好的选择是不要去学另一个Web framework，去学习ZeroMQ或是Redis，这两者对于Web development也非常有帮助，这样就做到了最大化差异。从构建一个程序员的技术理念角度，我会推荐每一个程序至少去了解Lisp或是一门Functional programming language，不管你是否会在可见的未来用到，它们能让你从一个不同的角度看待编程。&lt;/p&gt;
&lt;p&gt;最后我建议每个程序员都应该经营一款自己的产品，它可以是一款app，一个网站或是一个开源软件。除非你是一个创业公司的早期员工，不然你可能没有机会将所有学到的技术或是理念都付之实践，有很多人想成为全栈工程师，最快的捷径就是打造一款自己的产品。任何一个设计师都会精心打造自己的Portfolio，但大部分程序员却不会。当评估一个程序员的Coding能力时，我会去看他的Github上是否有出彩的项目，可惜国内绝大部分程序员的Github空空如也，或者只有一些非常简单的程序。我建议大家好好经营自己Github上项目，这不但可以提高你的声誉，对你将来的求职也非常有帮助。当你报怨求职面试时又被问到各种无厘头的程序题时，有没有想过面试官也很无奈，因为他没有任何其他方法得知你的Coding能力究竟如何。如果每一个程序员都有自己的作品，我想程序员的面试会简单许多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重视沟通能力的培养&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当被问到“你觉得Junior Developer和Senior Developer最大的差别是什么”时，我最自然的反应是沟通与文档。沟通包括程序员团队内部的沟通，与其他团队的沟通，与Manager的沟通等等。我不认为自己有能力把这些问题非常概括地说清楚，不过我可以给一条建议，那就是先学会和你的Manager沟通，让他来教你其余的部分。许多公司都会设置Manager与组员的1:1，一个有效率的1:1应该大部分时间有组员来主导。这需要你在1:1之前花足够多的时间来考虑要问的问题，并且最好提前1天发给Manager，让他有机会思考答案。许多人对此不太重视，或者只问非常具体的问题而不是一些开放性问题，这样你很难在你的Manager身上学到东西。如果你渐渐懂得如何利用1:1的时间，它很会成为你在工作中单位时间投资回报率最高的活动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;累积你的人脉&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个人都明白人脉的重要性，但实际做起来却不容易。参加一些线下的会议或是活动，可能是最直接的扩展人脉的方式之一。可惜大部分人似乎只是去听了一场技术讲座就回家了。当然，这和不少活动的时间安排也有关系，讲座时间排得太满，茶歇时间短，加上有时嘉宾迟到或是没控制好时间，干脆就把茶歇取消了。而实际上，结识一两个同道中人远比听技术讲座有价值。下次去参加这类会议，不妨给你自己设个目标，比如至少加两个同行的微信。之后维系你的人脉可能需要花更多的时间，下了班或是周末找你的朋友们喝个咖啡吧！&lt;/p&gt;
&lt;p&gt;另外我觉得每个人都需要一个职场导师，他可以是你第一份工作的导师或是Manager，也可以是你认识的其他前辈。你们需要维系一个非常长期的关系，不止于一家公司，最好贯穿你的整个职业生涯。每当你遇到疑惑时，都可以询求他的建议，我觉得这将是你最宝贵的一笔人脉财富。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寻找发挥你才华的平台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后也是最重要的一步，找到适合你的公司。做为求职者评估一家公司可以看三个方面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公司的发展前景（大公司的话，看所在部门的发展前景）&lt;/li&gt;
&lt;li&gt;你将要加入的团队&lt;/li&gt;
&lt;li&gt;薪资福利&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以在面试一家公司的时候，你要意识到面试是双向的，公司在面试你的同时，你也在面试这家公司。面试前你应该对这家公司做足功课，准备好一些有质量的问题，比如指出产品中的问题，询问开发流程或是如何做绩效评估。到时你也可以检验一下你的面试官是否合格。&lt;/p&gt;
&lt;p&gt;每次选择公司对以上三个方面都应兼顾，但在职业生涯的不同阶段，侧重点不同。比如，在刚刚工作时，加入一个优秀的团队最为重要，他们可以教会你很多东西，提升你的能力。工作5年之后，你需要一个平台施展你的才华，体现个人价值，公司发展前景的重要性迅速提升。当你做出一番成绩，证明了自己的价值之后，逐渐进入收获期，就有了与公司要价的资格。另一方面，团队实力对公司的前景也有很大的影响。&lt;/p&gt;
&lt;p&gt;对一个刚毕业，初入职场的同学，一个近几年被问了无数次的问题“我的第一份工作是去创业公司还是大公司？”我的回答仍旧是“加入一个优秀的团队最为重要”。一些知名的大公司，团队的素质是有一定保证，但创业公司则不然，团队素质参差不齐，所以如我前面所说你需要面试这个团队，做出自己的判断。不过除了团队因素之外，我想提一下毕业生去创业公司的几个好处。首先，在刚毕业的一段时间内，经济压力小，是最自由最能承受风险的时期，而这段时间往往不长，所以应把握好这个去创业公司的黄金时段。其次，所有的学生进入大公司后，都会担任初级职位，某种程度上来讲是学校学习的延续，规范有条理，但缺乏独立性和创新性，而这正是中国大部分学生所欠缺的。这方面的能力在一家创业公司可以得到快速锻炼，而在大公司可能要等升到中级职位后才有这方面的机会。个人观点，仅供参考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我觉得步入职场的前3年对今后的发展尤其重要，希望此文能对年轻的程序员们有所帮助。欢迎评论！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;叶剑烨&lt;/strong&gt; &lt;a href=&quot;http://yejianye.com&quot;&gt;http://yejianye.com&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[技术路线的选择重要但不具有决定性]]></title><description><![CDATA[最近微软在技术上连续有大动作，在PDC上发布了Windows Azure云计算平台，预告了Visual Studio 2010、.NET 4.0和C# 4.…]]></description><link>https://griddy.netlify.com//blog/career-roadmap/</link><guid isPermaLink="false">https://griddy.netlify.com//blog/career-roadmap/</guid><pubDate>Sun, 10 Nov 2019 21:24:06 GMT</pubDate><content:encoded>&lt;p&gt;最近微软在技术上连续有大动作，在PDC上发布了Windows Azure&lt;a href=&quot;http://lib.csdn.net/base/hadoop&quot;&gt;云计算&lt;/a&gt;平台，预告了Visual Studio 2010、.NET 4.0和C# 4.0。如果放在几年前，我相信微软粉丝们一定是欢声雷动，不过这次情况有点不太一样，在网上看到有人在抱怨微软技术更新速度太快而且四面出击，还有人扬言要改弦更张，投奔&lt;a href=&quot;http://lib.csdn.net/base/linux&quot;&gt;Linux&lt;/a&gt;或者&lt;a href=&quot;http://lib.csdn.net/base/java&quot;&gt;Java&lt;/a&gt;阵营。我本人也收到一封来信，写信人大意是说自己大学时选择.NET路线，一路跟下来很辛苦，2.0还没学好，人家已经4.0预览了，感到很困惑，问我该怎么办。老实讲，这样的问题我无法回答，每个人具体情况不同，所应该采取的态度和解决方案也不同。从我自己来讲，其实技术路线问题也曾长时间地困扰我，所以我想把我现在的一些想法摊出来跟大家分享一下。罗列如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;根据我长期的观察，做开发技术的人按照其人生路线设计，可以分成几类。第一类是把自己的命运寄托在一项事业上。这样的人知道自己想干什么，而且有能力把技术当工具来实现自己的想法和事业。这里所说的事业是广义的，并不是说你非要自己开公司当老板，而是说你认可一件事情，比如促进人们交流和言论自由，带给大家更多娱乐，提升大众身心健康水平，增强国家国防实力，或者提升某个行业的信息化水平，然后你能够以技术为手段，在这个事情上做出成绩。这种人做着自己认为值得一生投入的事情，愿意领略这一追求带来的人生起伏并且无怨无悔，我认为这是做技术的最高层次。第二类是把自己的命运寄托在组织和团队上。这种人虽然不知道自己到底想干什么，但是技术水平出色，而且综合素质突出，勇于变化，能够把技术当敲门砖进入某个优秀的团队，以团队的目标为目标，依据团队的需求而转型或者坚持，跟团队一起干出一番成绩。这类人有令人羡慕的职业背景，在大公司里高薪厚禄，生活比较安定舒适，但是中年以后会经常自问到底做了什么&lt;strong&gt;自己想做的事情&lt;/strong&gt;，为自己过于风平浪静的人生感到惆怅。但总的来说，这个层次也是比较高的。第三种是把命运寄托在技术上。这种人有能力成为技术的专家，然后就希望奇货可居，待价而沽，把技能当商品出售谋求富足人生。这种人没有大的人生目标，不想把自己的命运跟企业和组织绑定在一起，也不愿意做什么改变，只是满足于技术高手的层面，寄希望于其技术专长能够长期值钱，有点投机主义者的意思。第四种是还处于出卖劳动力的阶段，在这里就不多说了。&lt;/p&gt;
&lt;p&gt;我想说的是，在过去很多年里，很多技术人实际上是把自己定位在第三种人里。而实际上，只有成为第一类和第二类人，才算达到了比较成功的状态。第三类人实际上最危险，因为技术的变迁不但是&lt;strong&gt;可能&lt;/strong&gt;的，而且是&lt;strong&gt;一定&lt;/strong&gt;的。他们要么马上被淘汰，要么追得老了累了追不动了以后被淘汰，被淘汰只是时间问题。 因此，如果你认为某个软件技术的兴起或者衰落对你个人的职业生涯构成了&lt;strong&gt;决定性&lt;/strong&gt;的影响，那么你可能正走在错误的路线上，应当尽快改弦更张。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对个体软件人来说，什么是核心竞争力？不是时间差，不是技术，不是基本功，不是什么思想，也不是聪明脑瓜，而是你独特的个性知识经验组合。&lt;/p&gt;
&lt;p&gt;有人看到新技术出来了，急急忙忙赶上去尝鲜，以为自己快人一步，就能如何如何，实际上这种想法根本不靠谱，最多在论坛博客上风光两天，等这项技术投入实际应用以后一点便宜也占不到。&lt;/p&gt;
&lt;p&gt;有人把某个技术、框架、平台研究得里外通透，以为这样就能奇货可居。实践中，这种人能红火一时，但很难超过5年。这是现阶段技术发展生命周期所决定的。此外，现在越来越多人意识到了，能够靠读书看文章读代码做练习学会的东西没什么门槛，智力正常的人只要愿意花功夫，都不难达到你的程度。有的人认为，自己有能力驾驭技术潮流，哪个红学哪个。我在技术行业里不敢说阅人无数，见过的高手上百是有的，说句不怕得罪人的话，能够连续抓住两个以上的潮流并且始终处于领先位置的人及其少见，一只手就数的过来。更常见的情况是，上一个阶段的成功会成为下一个阶段的障碍，所谓随机应变屹立潮头之说，往往只不过是当红小生给自己壮胆的狂言，时过境迁之后，他就只能听着新一代当红小生的豪言壮语而默默苦笑。&lt;/p&gt;
&lt;p&gt;有人强调基本功，这是对的。在任何技术性行业里都一样，基础打得多深，上面就能造得多高。现实中，基本功扎实的人很少见，这跟中国教育的弊病有关，所以基本功好的人，一般应变能力强，学习速度快，比较受欢迎。但说基本功是核心竞争力，还是没有抓住本质。我们经常能看到基本功差不多的两个人，一个发展的很好，一个发展平平，这表明基本功成功职业生涯的是重要条件，但不是决定因素。&lt;/p&gt;
&lt;p&gt;有人强调这个那个思想，实际上软件行业里的伟大的思想就那么屈指可数的几个，窗户纸一点就破，其他衍生出来的思想，就跟技术风潮一样，各领风骚三五年，成不了你核心竞争力。&lt;/p&gt;
&lt;p&gt;还有人强调自己的智商，聪明脑瓜，觉得自己比别人聪明，自己的聪明是核心竞争力。大学生、刚毕业的人持这个观点的比较多，然而有过人生阅历以后，自然会对这种观点不以为然。本质上这是因为社会对于“聪明”的定义与学校不同，一个解题高手在学校里可能是受人仰慕的聪明脑瓜，但在职业人生中则可能是个大傻蛋。我们身边很多人走了一条不尽如意的人生道路，往往不是因为他们不够“聪明”，而是因为他们太“聪明”了，聪明反被聪明误。我想这也是为什么人们要发明“智慧”这个词以区别于“聪明”的原因。另外，关于这种观点，还有一点不得不指出，那就是在软件这个行当里，一般聪明就可以了，绝顶聪明占不到多少便宜。&lt;/p&gt;
&lt;p&gt;那么核心竞争力是什么？我观察圈子里很多成功和不成功的技术人，提出一个观点，那就是个人的核心竞争力是是他独特的个性知识经验&lt;strong&gt;组合&lt;/strong&gt;。这个行业里拥挤着上百万聪明人，彼此之间真正的不同在哪里？不在于你学的是什么技术，学得多深，IQ多少，而在于你身上有别人没有的独特的个性、背景、知识和经验的组合。如果这种组合，1，绝无仅有；2，在实践中有价值，3，具有可持续发展性，那你就具备核心竞争力。因此，当设计自己的发展路线时，&lt;strong&gt;应当最大限度地加强和发挥自己独特的组合，而不是寻求单项的超越&lt;/strong&gt;。而构建自己独特组合的方式，主要是通过实践，其次是要有意识地构造。关于这个观点，话题太大，我不打算赘述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;虽然技术路线的选择不是核心竞争力，也不应该具有决定性，但对于个人职业路线还是具有比较重要的影响力。但这并不是说，我们应该煞有介事地把自己归于Java或者.NET技术阵营，整天捧本书吭哧吭哧啃。正确的态度应该是着重于你要干的事情，然后认真把这件事情做好，通过必要的学习将所需的知识体系构筑完整，在整个过程中及时更新知识体系。只有心理没谱的人，才会为新技术的推出感到惶恐，因为他不知道自己要干什么，也就不知道自己要学什么，看到什么东西出来了都以为如果不学就会落伍，才会觉得是个压力，日积月累，才会痛苦彷徨嚷嚷怎么办。相反，如果你很清楚地知道自己要做什么，就会发现，其实必须及时更新的知识变化并不频繁，大多数新鲜玩意根本不在自己关注范围内，任他三仙落地，五佛升天，与我何干？因此完全可以安步当车，稳扎稳打。&lt;/li&gt;
&lt;li&gt;几年前我刚加入CSDN的时候，.NET和Java之争是最热门的话题。现在回过头看，其实当时无论你选择那条路，如果认真做下去，搞些实事，别玩虚活的话，现在都应该有成就了。当然，客观上来说，这几年微软技术变化是比较快，弯弯绕得比较多，相比之下，如果当时你选择的是Java，可能这几年过的比较幸福一些，这是事实。我对此并不是没有自己的看法，但是这毕竟不是多么大的问题，实际上Java这几年折腾得也够猛，只不过作为一个比较开放的领域，Java为其追随者保留了更多的自由度，而微软的追随者大多数有一种被驱赶的感觉而已。话说回来， 微软的技术变革并不是没有章法的，其今天的技术&lt;a href=&quot;http://lib.csdn.net/base/architecture&quot;&gt;架构&lt;/a&gt;，早在2003年就已经明明白白地公诸于众，只不过因为某些微妙的原因，一些微软跟随者这几年被带着兜了一些圈子，浪费了一些精力，比较辛苦。不过，现在.NET技术体系的尘埃基本落定，从体系结构上看，相对稳定的时期已经到来，投资微软技术可以放心。&lt;/li&gt;
&lt;li&gt;不过我相信未来不同技术流的应用领域会出现一些明显的分化。在中国，涉及国防、国家安全、命脉产业和关键行业的服务端要害系统，国产化改造是阻挡不住的潮流，长期来看，开源和Java将在这个领域占据主导低位。其他的领域，随着微软技术变革的的大势确定，相信微软的优势不可小觑。这里没有考虑中国政府可能做出的产业调整政策。这次微软黑屏事件，无论是否出于微软本意，其最大的效果在于向有关部门展示了一下其信息战力，中国政军内部有关机构对此不可能不加以警惕，这是否会引起中国国内IT产业政策的调整，现在还不得而知。但我相信，微软系统恐怕将在不长的时间里与中国关键要害领域的核心系统彻底说拜拜。未来中国IT系统的格局，很有可能是居庙堂之高则清一色&lt;a href=&quot;http://lib.csdn.net/base/linux&quot;&gt;linux&lt;/a&gt;/Java，处江湖之远则Windows占主导。&lt;/li&gt;
&lt;li&gt;几年前还有一个热烈争论，就是Java和C#之争。现在实际上尘埃已经落定，两个语言的定位已经分道扬镳。Java实际上已经落实了成为系统语言的诺言，在现在的计算机体系结构上，Java与15年前的C一样，可以成为构造基础设施的利器，而且其性能相当不错，完全突破了之前人们对虚拟机语言的认识局限性。我相信在未来，Java将有效地侵蚀&lt;a href=&quot;http://lib.csdn.net/base/c&quot;&gt;C语言&lt;/a&gt;的一些曾经以为千秋万代永不变色的地盘。虽然同时Java也在向上发展，但是其力度与C#不可同日而语。相反，C#主要是在往上发展，即将成为超级瑞士军刀，微软版十全大补膏，所有于应用开发有意义的特性都要加上，从编程语言发展来看，它将成为一株奇葩。作为一个编程语言的爱好者，我正饶有兴致地注视着史上特性最丰富语言C#的发展动向。但是，不得不指出，C#的弱点在脚跟。自从用它开发Longhorn Avalon失败以后，微软暂时放弃了让C#成为系统语言的努力，专心专意让C#变成应用开发领域的超级无敌霸王3000，而在核心领域，仍然是C++、COM当关。这就出现了有趣的局面，在可见的未来，微软体系内真正的核心软件基础设施，还是将由微软自己用C++来构造，而组合装配的应用开发，则由C#完成。VB和CLR平台上的其他动态语言都不会有太多机会，因为C#将穷尽神智正常者一切关于语言的幻想。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上几点，如果有人现在要选择技术路线，可以参考一下。但切记，技术路线的选择重要，但不具有决定意义。&lt;/p&gt;
&lt;p&gt;孟岩 &lt;a href=&quot;http://blog.csdn.net/myan/article/details/3247071&quot;&gt;http://blog.csdn.net/myan/article/details/3247071&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[NoSQL Databases: An Overview]]></title><description><![CDATA[Over the last few years we have seen the rise of a new type of databases, known as NoSQL databases, that are challenging the dominance of…]]></description><link>https://griddy.netlify.com//blog/nosql-databases-an-overview/</link><guid isPermaLink="false">https://griddy.netlify.com//blog/nosql-databases-an-overview/</guid><pubDate>Sun, 10 Nov 2019 21:10:51 GMT</pubDate><content:encoded>&lt;p&gt;Over the last few years we have seen the rise of a new type of databases, known as NoSQL databases, that are challenging the dominance of relational databases. Relational databases have dominated the software industry for a long time providing mechanisms to store data persistently, concurrency control, transactions, mostly standard interfaces and mechanisms to integrate application data, reporting. The dominance of relational databases, however, is cracking.&lt;/p&gt;
&lt;p&gt;Author: Martin Fowler &lt;a href=&quot;https://www.thoughtworks.com/de/insights/blog/nosql-databases-overview&quot;&gt;https://www.thoughtworks.com/de/insights/blog/nosql-databases-overview&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;NoSQL what does it mean&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;What does NoSQL mean and how do you categorize these databases? NoSQL means Not Only SQL, implying that when designing a software solution or product, there are more than one storage mechanism that could be used based on the needs. NoSQL was a hashtag (#nosql) choosen for a meetup to discuss these new databases. The most important result of the rise of NoSQL is Polyglot Persistence. NoSQL does not have a prescriptive definition but we can make a set of common observations, such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Not using the relational model&lt;/li&gt;
&lt;li&gt;Running well on clusters&lt;/li&gt;
&lt;li&gt;Mostly open-source&lt;/li&gt;
&lt;li&gt;Built for the 21st century web estates&lt;/li&gt;
&lt;li&gt;Schema-less&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;Why NoSQL Databases&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 720px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 53.75%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAACAUlEQVQoz1WSy27TQBSG+xosUHe8AZcXoM+AWLLsAgJhAQI2peIiVQKhVkoRaqNCEiGKiirqDaRS1ZQ0xa6TlAClONO6beKk2B7bM2N7xnawndRqjkajkc5885//nBnpxeEzz6+2/O9Hflmmsu54rmPbnueFqSAIwh1Dy1RUamBHsxhy+tRIL0r1HEyqT7Li/UxlfKq5UrKorama67rRu74f7q4CoQiM+j7cbuJm5xSOg7h2QXi/IORfb82VmhXVQi31xAnhIOgr+0FA48PZGMAuY+Knr1tvFut5rpZbEd8u15a+EGLHylHxXdhtHOyAriQpewpsD8HUYx/Hp2cvpjNX7mYupzOX0vnrzxHGiWc7NIKhjg0NQcvBA7hfisfotdm1c/c+jz7kRh9x5x9wYy+LCJMEdgxkHCpUNZhqehYZVmZsee5V9vHthck78xOp+YlbH2aeIhQp+F7UMB0oUlGUNxpgrR4aiJgggSnlef5bab2yuSmKYlXga6KACQ5lGYs818Hhu2J5cZ3PrZZLP/70KzptGGVH3ItOIaXkU2r2hrSaq+0CQs54th1NM0wThYuQZM7xoB1K/xVu2jNX0fQYmbwAlp4JvwBBVtSO+Ku4etsE266y63V++/B4yHN4Qz+W4EEDyj/h/o7alk9UjVGaKLuWZrX/WgowW3tEG4zqPxvKR5rWQ9fyAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;nosqlintro&quot;
        title=&quot;nosqlintro&quot;
        src=&quot;/static/69b39cced9f5c25029791796fe2890ff/6da3e/nosqlintro.png&quot;
        srcset=&quot;/static/69b39cced9f5c25029791796fe2890ff/b059c/nosqlintro.png 180w,
/static/69b39cced9f5c25029791796fe2890ff/8f8c6/nosqlintro.png 360w,
/static/69b39cced9f5c25029791796fe2890ff/6da3e/nosqlintro.png 720w,
/static/69b39cced9f5c25029791796fe2890ff/e9c61/nosqlintro.png 1080w,
/static/69b39cced9f5c25029791796fe2890ff/8d0ff/nosqlintro.png 1440w,
/static/69b39cced9f5c25029791796fe2890ff/2f950/nosqlintro.png 1600w&quot;
        sizes=&quot;(max-width: 720px) 100vw, 720px&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Application developers have been frustrated with the impedance mismatch between the relational data structures and the in-memory data structures of the application. Using NoSQL databases allows developers to develop without having to convert in-memory structures to relational structures. &lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 720px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 58.75%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABl0lEQVQoz31SS0sCURj1R7SpbUEQQe2CgqDHsr9QEBEEuYk20cJFuGjXppbSoiBpZQha9jAC85XOjNqoiYYWNOrM3MeYzvgYuzY0ag0d7uo759xz7sc1tX+gqiqWJIgQwrjVaunzer1OhhKSKqjDyoqiU6Z2DwBEHxzHC0JLVX+ZmfdMpJAWIVQMzSSZiERRBBDqyZ07mmqMyw05zYPOzdsC026SoWqQ/BeameayA44Ncjx5ytjcbDS8F2f2o/1Lu+0TI61Lp3ajgSuVJP+W4PNQwuQVfbU1ERLK6wvjq7OjKzMjKTpEJr1rI/md04+uGfCltbkx89LU8vQwG/X3momgVqtVq1X1G/0L0+rVFbfddnKw5zg+REDoNsI49ZLJ5LKZ11wynRYA0Kn/FqYpBFF8ouhHX9DnC4QiEa5YMjCTkgmWjVI0E4vLsqwrIEY+r9+6aLHOW24cdzwUjc1MPBEIhiMULctKt3YF37sfdia2die3XacuAQNjM5tKUyT3mdX+oKYQAYhSjOf8+sruCYejxXJZp74ApgOQhHeq9DkAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;nosqlintegrationdatabase&quot;
        title=&quot;nosqlintegrationdatabase&quot;
        src=&quot;/static/5ccdc97e71bdf2b44e894ccdc7d1cc85/6da3e/nosqlintegrationdatabase.png&quot;
        srcset=&quot;/static/5ccdc97e71bdf2b44e894ccdc7d1cc85/b059c/nosqlintegrationdatabase.png 180w,
/static/5ccdc97e71bdf2b44e894ccdc7d1cc85/8f8c6/nosqlintegrationdatabase.png 360w,
/static/5ccdc97e71bdf2b44e894ccdc7d1cc85/6da3e/nosqlintegrationdatabase.png 720w,
/static/5ccdc97e71bdf2b44e894ccdc7d1cc85/e9c61/nosqlintegrationdatabase.png 1080w,
/static/5ccdc97e71bdf2b44e894ccdc7d1cc85/8d0ff/nosqlintegrationdatabase.png 1440w,
/static/5ccdc97e71bdf2b44e894ccdc7d1cc85/2f950/nosqlintegrationdatabase.png 1600w&quot;
        sizes=&quot;(max-width: 720px) 100vw, 720px&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;There is also movement away from using databases as integration points in favor of encapsulating databases with applications and integrating using services. &lt;/p&gt;
&lt;p&gt;The rise of the web as a platform also created a vital factor change in data storage as the need to support large volumes of data by running on clusters. &lt;/p&gt;
&lt;p&gt;Relational databases were not designed to run efficiently on clusters.&lt;/p&gt;
&lt;p&gt;The data storage needs of an ERP application are lot more different than the data storage needs of a Facebook or an Etsy, for example. &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Aggregate Data Models:&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Relational database modelling is vastly different than the types of data structures that application developers use. Using the data structures as modelled by the developers to solve different problem domains has given rise to movement away from relational modelling and towards aggregate models, most of this is driven by &lt;em&gt;Domain Driven Design&lt;/em&gt;, a book by Eric Evans. An aggregate is a collection of data that we interact with as a unit. These units of data or aggregates form the boundaries for ACID operations with the database, Key-value, Document, and Column-family databases can all be seen as forms of aggregate-oriented database.&lt;/p&gt;
&lt;p&gt;Aggregates make it easier for the database to manage data storage over clusters, since the unit of data now could reside on any machine and when retrieved from the database gets all the related data along with it. Aggregate-oriented databases work best when most data interaction is done with the same aggregate, for example when there is need to get an order and all its details, it better to store order as an aggregate object but dealing with these aggregates to get item details on all the orders is not elegant.&lt;/p&gt;
&lt;p&gt;Aggregate-oriented databases make inter-aggregate relationships more difficult to handle than intra-aggregate relationships. Aggregate-ignorant databases are better when interactions use data organized in many different formations. Aggregate-oriented databases often compute materialized views to provide data organized differently from their primary aggregates. This is often done with map-reduce computations, such as a map-reduce job to get items sold per day.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Distribution Models:&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Aggregate oriented databases make distribution of data easier, since the distribution mechanism has to move the aggregate and not have to worry about related data, as all the related data is contained in the aggregate. There are two styles of distributing data:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sharding: Sharding distributes different data across multiple servers, so each server acts as the single source for a subset of data.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Replication: Replication copies data across multiple servers, so each bit of data can be found in multiple places. Replication comes in two forms,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Master-slave replication makes one node the authoritative copy that handles writes while slaves synchronize with the master and may handle reads.&lt;/li&gt;
&lt;li&gt;Peer-to-peer replication allows writes to any node; the nodes coordinate to synchronize their copies of the data.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Master-slave replication reduces the chance of update conflicts but peer-to-peer replication avoids loading all writes onto a single server creating a single point of failure. A system may use either or both techniques. Like Riak database shards the data and also replicates it based on the replication factor.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;CAP theorem:&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;In a distributed system, managing consistency(C), availability(A) and partition toleration(P) is important, Eric Brewer put forth the CAP theorem which states that in any distributed system we can choose only two of consistency, availability or partition tolerance. Many NoSQL databases try to provide options where the developer has choices where they can tune the database as per their needs. For example if you consider &lt;a href=&quot;http://basho.com/riak&quot;&gt;Riak&lt;/a&gt; a distributed key-value database. There are essentially three variables r, w, n where&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;r=number of nodes that should respond to a read request before its considered successful.&lt;/li&gt;
&lt;li&gt;w=number of nodes that should respond to a write request before its considered successful.&lt;/li&gt;
&lt;li&gt;n=number of nodes where the data is replicated aka replication factor.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In a Riak cluster with 5 nodes, we can tweak the r,w,n values to make the system very consistent by setting r=5 and w=5 but now we have made the cluster susceptible to network partitions since any write will not be considered successful when any node is not responding. We can make the same cluster highly available for writes or reads by setting r=1 and w=1  but now consistency can be compromised since some nodes may not have the latest copy of the data. The CAP theorem states that if you get a network partition, you have to trade off availability of data versus consistency of data. Durability can also be traded off against latency, particularly if you want to survive failures with replicated data.&lt;/p&gt;
&lt;p&gt;NoSQL databases provide developers lot of options to choose from and fine tune the system to their specific requirements.  Understanding the requirements of how the data is going to be consumed by the system, questions such as is it read heavy vs write heavy, is there a need to query data with random query parameters, will the system be able handle inconsistent data.&lt;/p&gt;
&lt;p&gt;Understanding these requirements becomes much more important, for long we have been used to the default of  RDBMS which comes with a standard set of features no matter which product is chosen and there is no possibility of choosing some features over other. The availability of choice in NoSQL databases, is both good and bad at the same time. Good because now we have choice to design the system according to the requirements. Bad because now you have a choice and we have to make a good choice based on requirements and there is a chance where the same database product may be used properly or not used properly.&lt;/p&gt;
&lt;p&gt;An example of feature provided by default in RDBMS is transactions, our development methods are so used to this feature that we have stopped thinking about what would happen when the database does not provide transactions. Most NoSQL databases do not provide transaction support by default, which means the developers have to think how to implement transactions, does every write have to have the safety of transactions or can the write be segregated into “critical that they succeed” and “its okay if I lose this write” categories. Sometimes deploying external transaction managers like &lt;a href=&quot;https://zookeeper.apache.org/&quot;&gt;ZooKeeper&lt;/a&gt; can also be a possibility.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Types of NoSQL Databases:&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;NoSQL databases can broadly be categorized in four types.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 720px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 58.25%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABdklEQVQoz2P4DwPfvn0Dkk8fP7l28vSNM2cfXL7y+PqNGzduXgejr1+//scADBDq379/375/BzIOXrkWtnpL9IadYRt3x2zaNWfVupUrVq9Yve7d+/cQZVg0A8FfsMSWa7fEd5yQ2XNGeNdJ2Z3HJ63ZsJokzSLbjynsOc2/84TY9qMTVq5buXTF0hVr373/gE8zROLU9Vu1ew63Hj7ZfOhE68Hjm/bs37Nn3/ZdewjYDJG4e/fenUsXX9y9/ebh/VcP7j178uT127fAAHv79i1hzfcfP9u7au6GCTWbp7WsbC8+uW3Vr7//bt+9++YNUZqf7lsxd2NfzZbJTas7Sk5uW/3j95/bd+4Qq3nvqjnrJ1VumtG4qr3o5NZVpGh++uzAgtnbqqu2VFSsqss/sXUlRDNRfr73/Om+5v7tDuk7bTOXpyUd3rz45++/t27dfvPmDRGa7z84febU2fOnz144ffbsqQvnL1y9cfPs+YsfPnzE1AwAH0N8TrSwu8cAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;nosqlkeyvaluedatabase&quot;
        title=&quot;nosqlkeyvaluedatabase&quot;
        src=&quot;/static/753cca776853ca2357ee815acf2b2b62/6da3e/nosqlkeyvaluedatabase.png&quot;
        srcset=&quot;/static/753cca776853ca2357ee815acf2b2b62/b059c/nosqlkeyvaluedatabase.png 180w,
/static/753cca776853ca2357ee815acf2b2b62/8f8c6/nosqlkeyvaluedatabase.png 360w,
/static/753cca776853ca2357ee815acf2b2b62/6da3e/nosqlkeyvaluedatabase.png 720w,
/static/753cca776853ca2357ee815acf2b2b62/e9c61/nosqlkeyvaluedatabase.png 1080w,
/static/753cca776853ca2357ee815acf2b2b62/8d0ff/nosqlkeyvaluedatabase.png 1440w,
/static/753cca776853ca2357ee815acf2b2b62/2f950/nosqlkeyvaluedatabase.png 1600w&quot;
        sizes=&quot;(max-width: 720px) 100vw, 720px&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key-Value databases&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Key-value stores are the simplest NoSQL data stores to use from an API perspective. The client can either get the value for the key, put a value for a key, or delete a key from the data store. The value is a blob that the data store just stores, without caring or knowing what&apos;s inside; it&apos;s the responsibility of the application to understand what was stored. Since key-value stores always use primary-key access, they generally have great performance and can be easily scaled.&lt;/p&gt;
&lt;p&gt;Some of the popular key-value databases are &lt;a href=&quot;http://basho.com/riak/&quot;&gt;Riak&lt;/a&gt;, &lt;a href=&quot;http://redis.io/&quot;&gt;Redis&lt;/a&gt; (often referred to as Data Structure server), &lt;a href=&quot;http://memcached.org/&quot;&gt;Memcached&lt;/a&gt; and its flavors, &lt;a href=&quot;http://www.oracle.com/technetwork/database/berkeleydb/index.html&quot;&gt;Berkeley DB&lt;/a&gt;, &lt;a href=&quot;http://upscaledb.com/&quot;&gt;upscaledb &lt;/a&gt;(especially suited for embedded use), Amazon DynamoDB (not open-source), Project Voldemort and &lt;a href=&quot;http://www.couchbase.com/&quot;&gt;Couchbase&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All key-value databases are not the same, there are major differences between these products, for example: Memcached data is not persistent while in Riak it is, these features are important when implementing certain solutions. Lets consider we need to implement caching of user preferences, implementing them in memcached means when the node goes down all the data is lost and needs to be refreshed from source system, if we store the same data in Riak we may not need to worry about losing data but we must also consider how to update stale data. Its important to not only choose a key-value database based on your requirements, it&apos;s also important to choose which key-value database.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Document databases&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 720px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 34.75%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsSAAALEgHS3X78AAAA60lEQVQY02P4DwP/QPjf3///px47VbBibfnaTYWrN+av3liwemPOirX1O/Z+/vMXqgwGGJA1//v7B8goaWlzsnMICAhycXZ1d/Pw8vS2s7KOy8r5DJT78+c/fs3FTa2ebu7RUdF+vv6hIWFA/ZZmFjEZWV/BTiNgc1FTq4+nd0REVFhoeFxsfFBQiKujc3xWLlGaS1raXRydw8IiQkLC3Nw8XF3dba1sYjOyvxHQDPZSUWOLrYVlcGAw0H4gcnVysTA2jU7NIKD5/19QeFZPme7sH+QbHecVEe0VHuUTFesWFJpcVfsVrApZMwDmTzluviEayQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;nosqldocumentdb&quot;
        title=&quot;nosqldocumentdb&quot;
        src=&quot;/static/781411762be01d91087c3812ddcac8dd/6da3e/nosqldocumentdb.png&quot;
        srcset=&quot;/static/781411762be01d91087c3812ddcac8dd/b059c/nosqldocumentdb.png 180w,
/static/781411762be01d91087c3812ddcac8dd/8f8c6/nosqldocumentdb.png 360w,
/static/781411762be01d91087c3812ddcac8dd/6da3e/nosqldocumentdb.png 720w,
/static/781411762be01d91087c3812ddcac8dd/e9c61/nosqldocumentdb.png 1080w,
/static/781411762be01d91087c3812ddcac8dd/8d0ff/nosqldocumentdb.png 1440w,
/static/781411762be01d91087c3812ddcac8dd/2f950/nosqldocumentdb.png 1600w&quot;
        sizes=&quot;(max-width: 720px) 100vw, 720px&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Documents are the main concept in document databases. The database stores and retrieves documents, which can be XML, JSON, BSON, and so on. These documents are self-describing, hierarchical tree data structures which can consist of maps, collections, and scalar values. The documents stored are similar to each other but do not have to be exactly the same. Document databases store documents in the value part of the key-value store; think about document databases as key-value stores where the value is examinable. Document databases such as MongoDB provide a rich query language and constructs such as database, indexes etc allowing for easier transition from relational databases.&lt;/p&gt;
&lt;p&gt;Some of the popular document databases we have seen are &lt;a href=&quot;https://www.mongodb.org/&quot;&gt;MongoDB&lt;/a&gt;, &lt;a href=&quot;http://couchdb.apache.org/&quot;&gt;CouchDB&lt;/a&gt; , &lt;a href=&quot;https://code.google.com/p/terrastore/&quot;&gt;Terrastore&lt;/a&gt;, &lt;a href=&quot;http://www.orientechnologies.com/orientdb/&quot;&gt;OrientDB&lt;/a&gt;, &lt;a href=&quot;http://ravendb.net/&quot;&gt;RavenDB&lt;/a&gt;, and of course the well-known and often reviled Lotus Notes that uses document storage.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Column family stores&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 720px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 37.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsSAAALEgHS3X78AAAB7UlEQVQY0y2OSWgTUQCGAx68efIm1HMREaktRbxoUUShNy/ignjwoFQq1KYlxWIxStowESpNUoWaLkmmTWObJmmz1HYek3kzb2bSybQpVmeJcbnpzZpZ8kyC8PHfPv7PYVlW+bMm7qtlpaqpqqYouqI2UDTt0ze9RaWBqn3V1KquVpurV03TxBg7DBvvZMndyAspRsQBTUIUoeEC5NJpqvx2XQ6kd6dScjC9lvmw/JFcyoXJ7PwGvW4aVlM+xPgnOWQ/b/vjvXAfcKfg/lkgneD2Xs/mv3QNit1O1P7ooNM1GHt5JvXw/GrfycWbo5tvsInrDbmGcSVB/PZd+vXu7mPAdgLpIiWeg6Xg0pZ4bYS6PrJ1xSnd8IyuTnYlB3qSro6V/gkq9F+2LBshVAAUZAoQcojleJYTWMQwLMdwHIMQK7AQQQbyLQSGLQpFwzCa2TWrflDI/MiF9OzCFIPcqDTGiC5Onl5LLI4Pz3mGZ8b6Z91Pp1NBb35yfMP3LOme347apt2U/1r4O71SS3kPM/5eij+yLR/bFB2g3BeNDPS0P7h8+k5329DVjlsx59H47ePL9xzh3ic5H7Za2YZdV3ZghU5WYDbES25enuBLnmI5BkA8QET9RDRAJGb8YRB/RYW8YM5DvU8I+Xrr+R8AlFdHL84GcAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;nosqlcolumnfamily&quot;
        title=&quot;nosqlcolumnfamily&quot;
        src=&quot;/static/541b2951c0959f4534b38317b342a48b/6da3e/nosqlcolumnfamily.png&quot;
        srcset=&quot;/static/541b2951c0959f4534b38317b342a48b/b059c/nosqlcolumnfamily.png 180w,
/static/541b2951c0959f4534b38317b342a48b/8f8c6/nosqlcolumnfamily.png 360w,
/static/541b2951c0959f4534b38317b342a48b/6da3e/nosqlcolumnfamily.png 720w,
/static/541b2951c0959f4534b38317b342a48b/e9c61/nosqlcolumnfamily.png 1080w,
/static/541b2951c0959f4534b38317b342a48b/8d0ff/nosqlcolumnfamily.png 1440w,
/static/541b2951c0959f4534b38317b342a48b/2f950/nosqlcolumnfamily.png 1600w&quot;
        sizes=&quot;(max-width: 720px) 100vw, 720px&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Column-family databases store data in column families as rows that have many columns associated with a row key (Figure 10.1). Column families are groups of related data that is often accessed together. For a Customer, we would often access their Profile information at the same time, but not their Orders.&lt;/p&gt;
&lt;p&gt;Each column family can be compared to a container of rows in an RDBMS table where the key identifies the row and the row consists of multiple columns. The difference is that various rows do not have to have the same columns, and columns can be added to any row at any time without having to add it to other rows.&lt;/p&gt;
&lt;p&gt;When a column consists of a map of columns, then we have a super column. A super column consists of a name and a value which is a map of columns. Think of a super column as a container of columns.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.datastax.com/&quot;&gt;Cassandra&lt;/a&gt; is one of the popular column-family databases; there are others, such as &lt;a href=&quot;https://hbase.apache.org/&quot;&gt;HBase&lt;/a&gt;, &lt;a href=&quot;http://hypertable.org/&quot;&gt;Hypertable&lt;/a&gt;, and Amazon DynamoDB. Cassandra can be described as fast and easily scalable with write operations spread across the cluster. The cluster does not have a master node, so any read and write can be handled by any node in the cluster.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Graph Databases&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 720px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 63.5%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAAB1klEQVQoz21SwWoVMRSdn/EL3LtxJbjtH7gQuhD8AHHloi4LgiAIbnShCIJuXVqtWipFSkd4k5m+Kb7M67x5M5NkktyMJ8nTTqWXEJKbe+49954k4ziSc9gPyvbG04Pru/vvfnJcLXnnf+acW/CK5UW9WuGa/AOfLLrtt8d33hx/Ymv4pBqmGBdirLVt12FprTdgPGhjlRSjI8CIDCKHYWiaNeIGrc/rOmM5r5aWSCPU2pjUg5HmdF7mxbxpO6l0L2SsUJzO5+WZVN5Wq0ZKySue/koXfHEBRmXUkVJZS13fzzIGWC8E/KCBp8jZN0hgNP4tHMART56zZ6sUliKyWnuYMYa8OWvlbPYsTXc4/xhByRiSttX6LC2rgpP1KQyac2EAYVToC6SM6Q4P7+3tbWXZ81CPEjDD6fWDV/evbT++/WgQfsjULU3+TRffSTSQDEQ8tdEpbafKJbEfnv1OP5+wH5mzxlc++tDv3hRPblm2H3t1UlMrrdSXwBdijqHtIJtBwbowy9xp5Z+kbh6+r+++FC++xAlNp+1PfS8YyyEOOnTBZ2iTdMCPOSqHr8zm51dXxlTbFkoJiBwmZDpY3+FKV33VS+DpZ8QupJwxWAHxNlTjmtgfACDkXoxiS58AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;nosqlgraph1&quot;
        title=&quot;nosqlgraph1&quot;
        src=&quot;/static/534fa75c93e112e075d46b6a8d0aaba8/6da3e/nosqlgraph1.png&quot;
        srcset=&quot;/static/534fa75c93e112e075d46b6a8d0aaba8/b059c/nosqlgraph1.png 180w,
/static/534fa75c93e112e075d46b6a8d0aaba8/8f8c6/nosqlgraph1.png 360w,
/static/534fa75c93e112e075d46b6a8d0aaba8/6da3e/nosqlgraph1.png 720w,
/static/534fa75c93e112e075d46b6a8d0aaba8/e9c61/nosqlgraph1.png 1080w,
/static/534fa75c93e112e075d46b6a8d0aaba8/8d0ff/nosqlgraph1.png 1440w,
/static/534fa75c93e112e075d46b6a8d0aaba8/2f950/nosqlgraph1.png 1600w&quot;
        sizes=&quot;(max-width: 720px) 100vw, 720px&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Graph databases allow you to store entities and relationships between these entities. Entities are also known as nodes, which have properties. Think of a node as an instance of an object in the application. Relations are known as edges that can have properties. Edges have directional significance; nodes are organized by relationships which allow you to find interesting patterns between the nodes. The organization of the graph lets the data to be stored once and then interpreted in different ways based on relationships.&lt;/p&gt;
&lt;p&gt;Usually, when we store a graph-like structure in RDBMS, it&apos;s for a single type of relationship (&quot;who is my manager&quot; is a common example). Adding another relationship to the mix usually means a lot of schema changes and data movement, which is not the case when we are using graph databases. Similarly, in relational databases we model the graph beforehand based on the Traversal we want; if the Traversal changes, the data will have to change.&lt;/p&gt;
&lt;p&gt;In graph databases, traversing the joins or relationships is very fast. The relationship between nodes is not calculated at query time but is actually persisted as a relationship. Traversing persisted relationships is faster than calculating them for every query.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 720px;&quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsSAAALEgHS3X78AAABD0lEQVQoz42QS1KEQAyGuZAH8hjexFu48gZWeQDdWS5UXME8gAGmST/SpLsx0BSFWjj+i1SSypdXMqzkQ2B7ffea3Dxc3T75MRrCsKlkHcS651zcvxSPaRPCH+AvGA1ag0sfRJStCOQuw2EIUgAJzcvXZW2FJkcIOpD/Bzxp9rmBn31jsGlbANkT9eQ6kE17RrQzTET7/SHLdwaRC1oBljwr9gKALNtV1UlpIzWyk2W5lGqGuQ6k7ERH03nT1HDxW9/W9s6B0jxymLAIazNOW921ATvn0PbKICizJMk5v71C8iOOb7PW8iE8dmxKo9jhJJ/KdhOOqpvmI/08HAu0thLqKAxYV1ant/e0KKul7AuMV4Kt168WBgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;nosqlgraph2&quot;
        title=&quot;nosqlgraph2&quot;
        src=&quot;/static/321169fbfefd699780501656e3fe7d8c/6da3e/nosqlgraph2.png&quot;
        srcset=&quot;/static/321169fbfefd699780501656e3fe7d8c/b059c/nosqlgraph2.png 180w,
/static/321169fbfefd699780501656e3fe7d8c/8f8c6/nosqlgraph2.png 360w,
/static/321169fbfefd699780501656e3fe7d8c/6da3e/nosqlgraph2.png 720w,
/static/321169fbfefd699780501656e3fe7d8c/e9c61/nosqlgraph2.png 1080w,
/static/321169fbfefd699780501656e3fe7d8c/8d0ff/nosqlgraph2.png 1440w,
/static/321169fbfefd699780501656e3fe7d8c/2f950/nosqlgraph2.png 1600w&quot;
        sizes=&quot;(max-width: 720px) 100vw, 720px&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Nodes can have different types of relationships between them, allowing you to both represent relationships between the domain entities and to have secondary relationships for things like category, path, time-trees, quad-trees for spatial indexing, or linked lists for sorted access. Since there is no limit to the number and kind of relationships a node can have, they all can be represented in the same graph database.&lt;/p&gt;
&lt;p&gt;Relationships are first-class citizens in graph databases; most of the value of graph databases is derived from the relationships. Relationships don&apos;t only have a type, a start node, and an end node, but can have properties of their own. Using these properties on the relationships, we can add intelligence to the relationship—for example, since when did they become friends, what is the distance between the nodes, or what aspects are shared between the nodes. These properties on the relationships can be used to query the graph.&lt;/p&gt;
&lt;p&gt;Since most of the power from the graph databases comes from the relationships and their properties, a lot of thought and design work is needed to model the relationships in the domain that we are trying to work with. Adding new relationship types is easy; changing existing nodes and their relationships is similar to data migration, because these changes will have to be done on each node and each relationship in the existing data.&lt;/p&gt;
&lt;p&gt;There are many graph databases available, such as &lt;a href=&quot;http://www.neo4j.org/&quot;&gt;Neo4J&lt;/a&gt;, &lt;a href=&quot;http://www.objectivity.com/infinitegraph&quot;&gt;Infinite Graph&lt;/a&gt;, &lt;a href=&quot;http://www.orientechnologies.com/orientdb/&quot;&gt;OrientDB&lt;/a&gt;, or &lt;a href=&quot;https://github.com/twitter/flockdb&quot;&gt;FlockDB&lt;/a&gt; (which is a special case: a graph database that only supports single-depth relationships or adjacency lists, where you cannot traverse more than one level deep for relationships).&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Why choose NoSQL database&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;We&apos;ve covered a lot of the general issues you need to be aware of to make decisions in the new world of NoSQL databases. It&apos;s now time to talk about why you would choose NoSQL databases for future development work. Here are some broad reasons to consider the use of NoSQL databases.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To improve programmer productivity by using a database that better matches an application&apos;s needs.&lt;/li&gt;
&lt;li&gt;To improve data access performance via some combination of handling larger data volumes, reducing latency, and improving throughput.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It&apos;s essential to test your expectations about programmer productivity and/or performance before committing to using a NoSQL technology. Since most of the NoSQL databases are open source, testing them is a simple matter of downloading these products and setting up a test environment.&lt;/p&gt;
&lt;p&gt;Even if NoSQL cannot be used as of now, designing the system using service encapsulation supports changing data storage technologies as needs and technology evolve. Separating parts of applications into services also allows you to introduce NoSQL into an existing application.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Choosing NoSQL database&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Given so much choice, how do we choose which NoSQL database? As described much depends on the system requirements, here are some general guidelines:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Key-value databases are generally useful for storing session information, user profiles, preferences, shopping cart data. We would avoid using Key-value databases when we need to query by data, have relationships between the data being stored or we need to operate on multiple keys at the same time.&lt;/li&gt;
&lt;li&gt;Document databases are generally useful for content management systems, blogging platforms, web analytics, real-time analytics, ecommerce-applications. We would avoid using document databases for systems that need complex transactions spanning multiple operations or queries against varying aggregate structures.&lt;/li&gt;
&lt;li&gt;Column family databases are generally useful for content management systems, blogging platforms, maintaining counters, expiring usage, heavy write volume such as log aggregation. We would avoid using column family databases for systems that are in early development, changing query patterns.&lt;/li&gt;
&lt;li&gt;Graph databases are very well suited to problem spaces where we have connected data, such as social networks, spatial data, routing information for goods and money, recommendation engines&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;Schema-less ramifications&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;All NoSQL databases claim to be schema-less, which means there is no schema enforced by the database themselves. Databases with strong schemas, such as relational databases, can be migrated by saving each schema change, plus its data migration, in a version-controlled sequence. Schema-less databases still need careful migration due to the implicit schema in any code that accesses the data.&lt;/p&gt;
&lt;p&gt;Schema-less databases can use the same migration techniques as databases with strong schemas, in schema-less databases we can also read data in a way that&apos;s tolerant to changes in the data&apos;s implicit schema and use incremental migration to update data, thus allowing for zero downtime deployments, making them more popular with 24*7 systems.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;All the choice provided by the rise of NoSQL databases does not mean the demise of RDBMS databases. We are entering an era of polyglot persistence, a technique that uses different data storage technologies to handle varying data storage needs. Polyglot persistence can apply across an enterprise or within a single application. &lt;/p&gt;
&lt;p&gt;For more details, read&lt;a href=&quot;http://martinfowler.com/books/nosql.html&quot;&gt; &lt;/a&gt;&lt;a href=&quot;http://martinfowler.com/books/nosql.html&quot;&gt;&lt;em&gt;NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence&lt;/em&gt;&lt;/a&gt; by Pramod Sadalage and Martin Fowler. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[Alex and Seira]]></title><description><![CDATA[Here is Alex with my OC who called Seira.]]></description><link>https://griddy.netlify.com//gallery/Alex-and-seira/</link><guid isPermaLink="false">https://griddy.netlify.com//gallery/Alex-and-seira/</guid><pubDate>Wed, 12 Jun 2019 19:21:41 GMT</pubDate><content:encoded>&lt;p&gt;Here is &lt;a href=&quot;https://www.artstation.com/artwork/oOBlXk&quot;&gt;Alex&lt;/a&gt; with my OC who called Seira.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Alex | Fanart]]></title><description><![CDATA[Here's fanart of Alex, an original character by Fanisyah Aurellia.]]></description><link>https://griddy.netlify.com//gallery/Alex-Fanart/</link><guid isPermaLink="false">https://griddy.netlify.com//gallery/Alex-Fanart/</guid><pubDate>Tue, 11 Jun 2019 19:21:41 GMT</pubDate><content:encoded>&lt;p&gt;Here&apos;s fanart of Alex, an original character by &lt;a href=&quot;https://www.artstation.com/fanisyahaurellia&quot;&gt;Fanisyah Aurellia&lt;/a&gt;. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[Mira]]></title><description><![CDATA[Mira is a fantasy place that i create for my comic project long time ago. It's a planet from another dimension that has three satelites. In…]]></description><link>https://griddy.netlify.com//gallery/mira/</link><guid isPermaLink="false">https://griddy.netlify.com//gallery/mira/</guid><pubDate>Mon, 10 Jun 2019 19:21:41 GMT</pubDate><content:encoded>&lt;p&gt;Mira is a fantasy place that i create for my comic project long time ago. It&apos;s a planet from another dimension that has three satelites. In fact, it&apos;s connected with the earth, the world as we know &quot;the astral world&quot;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Free Palestine]]></title><description><![CDATA[It's not about religion, it's about humanity]]></description><link>https://griddy.netlify.com//gallery/free-palestine/</link><guid isPermaLink="false">https://griddy.netlify.com//gallery/free-palestine/</guid><pubDate>Sun, 09 Jun 2019 19:21:41 GMT</pubDate><content:encoded>&lt;p&gt;It&apos;s not about religion, it&apos;s about humanity&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Wahyu]]></title><description><![CDATA[Here's the first commission that i take from my friend, Wahyu]]></description><link>https://griddy.netlify.com//gallery/wahyu/</link><guid isPermaLink="false">https://griddy.netlify.com//gallery/wahyu/</guid><pubDate>Fri, 07 Jun 2019 19:21:41 GMT</pubDate><content:encoded>&lt;p&gt;Here&apos;s the first commission that i take from my friend, Wahyu&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Stylized Portrait | Tribute to Razan al-Najjar]]></title><description><![CDATA[This is my tribute to Razan al-Najjar, a Palestinian nurse volunteering in the Gaza health ministry that died by gunshot on 1 June 201…]]></description><link>https://griddy.netlify.com//gallery/stylized-portrait-tribute-to-razan-al-najjar/</link><guid isPermaLink="false">https://griddy.netlify.com//gallery/stylized-portrait-tribute-to-razan-al-najjar/</guid><pubDate>Sat, 27 Oct 2018 00:26:47 GMT</pubDate><content:encoded>&lt;p&gt;This is my tribute to Razan al-Najjar, a Palestinian nurse volunteering in the Gaza health ministry that died by gunshot on 1 June 2018 (aged 21)&lt;/p&gt;</content:encoded></item></channel></rss>